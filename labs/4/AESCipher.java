/*
 * file: AESCipher.java
 * author: Harsha Kota
 * course: MSCS 630
 * assignment: Lab 4
 * due date: Wednesday, April 4, 2018
 * version: 1.0
 *
 * This file contains the declaration of the
 * AESCipher class.
 */

package lab4;

import java.util.ArrayList;

/*
 * AESCipher
 *
 * This class implements the Advanced Encryption Standard (AES) algorithm to produce 10 additional round keys
 * for a 128-bit key
 */
public class AESCipher {

  // Rijndael S-box
  private static final char[] SBOX =
    {
      0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
      0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
      0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
      0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
      0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
      0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
      0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
      0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
      0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
      0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
      0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
      0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
      0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
      0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
      0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
      0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    };

  // Rcon - Rijndael key schedule
  private static final char[] RCON =
    {
      0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
      0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
      0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
      0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
      0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
      0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
      0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
      0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
      0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
      0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
      0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
      0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
      0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
      0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
      0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
      0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
    };

  /*
   * aesSBox
   *
   * This function takes an input character and provides a substitution char using
   * the Rijndael S-box.
   *
   * Parameters:
   *   inHex:      char to be transformed using the Rijndael S-box
   *   it:         Integer value of the character, used as an index on Rijndael S-box
   *
   * Return value: Transformed character
   */
  private static char aesSBox(char inHex) {
    int it = (int) inHex;
    return SBOX[it];
  }

  /*
   * aesRcon
   *
   * This function takes an input integer and provides a constant from Rcon
   *
   * Parameters:
   *   round:       Integer value of the round, used as an index on RCON
   *
   * Return value:  Character from RCON for that round
   */
  private static char aesRcon(int round) {
    return RCON[round];
  }

  /*
   * aesRoundKeys
   *
   * This function performs AES specific transformations to the input 128-bit key
   * to generate 10 additional round keys, one on each round.
   *
   * Parameters:
   *   noOfKeys:      Original key + 10 rounds keys
   *   temp_key:      Hexadecimal values as string, split from the 128-bit key as a pair of 2 values
   *   key:           Holds the 128-bit key as an array of 16 ASCII character values
   *   W[][]:         4x44 matrix, since each key is made up of 16 ASCII values, each key making up a 4x4 matrix of W.
   *   answer:        Holds all round keys as strings
   *   temp_answer:   Temporary array to hold the key values as they are being build
   *   col:           Counter for the column index
   *   temp:          Holds W[col-1]
   *   firstItem:     Holds the first value from the temp[]
   *   temp_new:      Holds the transformed values from the aesSBox function for values in temp[]
   *   Rcon:          Holds the Round constant for the round
   *   temp_String:   Temporary string builder to build the key using Array W for every 4x4 row&column, going by column
   *
   *
   *
   *
   * Return value: String array of round keys including the original key
   */
  public static String[] aesRoundKeys(String KeyHex) {

    int noOfKeys = 11;

    // Splits the Key String to 16 ASCII Hexadecimal string values (pair of 2)
    // Parses Hexadecimal string to ASCII character value and stores them in a char array
    String[] temp_key = KeyHex.split("(?<=\\G.{2})");
    char[] key = new char[temp_key.length];
    for (int i=0; i<temp_key.length; i++) {
      key[i] = (char) Integer.parseInt(temp_key[i], 16);
    }

    char[][] W = new char[4][44];

    String[] answer = new String[noOfKeys];
    ArrayList<String> temp_answer = new ArrayList<>();

    int col = 0;

    // Step 1
    // W(0) = key(0), W(1) = key(1), W(2) = key(2), and W(3) = key(3)
    int counter = 0;
    for (int c=0; c<4; c++){
      for (int r=0; r<4; r++) {
        W[r][c] = key[counter];
        counter++;
      }
      col++;
    }

    /* Step 2
     * Perform various transformations using the given key in W(0), W(1), W(2), W(3)
     * to produce the round keys in the other 40 columns of W
     */
    while (col < W[0].length){

      // Part B
      // If the index of the column (col) is a multiple of 4, it indicates its a new round. Making every 4x4 matrix,
      // a key of size 16 in ASCII.
      if (col%4 == 0) {

        // Part I
        // For the construction of W[col], we will use the elements from the previous column W[col-1]
        char[] temp = new char[4];
        for (int r=0; r<4; r++) {
          temp[r] = W[r][col-1];
        }

        // Part II
        // Left Shift rows as follows: Wnew = [ W[1][col-1], W[2][col-1], W[3][col-1], W[0][col-1] ]
        char firstItem = temp[0];
        System.arraycopy(temp, 1, temp, 0, 3);
        temp[3] = firstItem;

        // Part III
        // Transform each of the values in Wnew using the SBOX
        char[] temp_new = new char[4];
        for (int r=0; r<4; r++) {
          temp_new[r] = aesSBox(temp[r]);
        }

        // Part IV
        // Get the Rcon round constant for the round. (Current round = col/4)
        char Rcon = aesRcon(col/4);

        // Part V
        // Perform an XOR operation on the first value in Wnew using the Rcon for the round
        temp_new[0] = (char) (Rcon ^ temp_new[0]);

        // Part VI
        // W[col] = W[col-4] XOR Wnew
        for (int r=0; r<4; r++) {
          W[r][col] = (char) (W[r][col-4] ^ temp_new[r]);
        }

        col++;

      } else {

        // Part A
        // If the index of the column (col) is not a multiple of 4. We XOR the fourth past and last column
        // with respect to col, W[col] = W[col-4] XOR W[col-1]
        for (int r=0; r<4; r++) {
          W[r][col] = (char) (W[r][col-4] ^ W[r][col-1]);
        }

        col++;

      }

    }

    StringBuilder temp_String = new StringBuilder();

    // Traverse through W by column converting each value to a 2-digit Hexadecimal Uppercase value.
    // After every 4th column, key is saved in temp_answer
    for (int c=0; c<W[0].length; c++) {
      if (c%4 != 0 || c==0) {
        for (int r=0; r<4; r++) {
          temp_String.append(String.format("%02X", (int) W[r][c]));
        }
      } else {
        temp_answer.add(temp_String.toString());
        temp_String.setLength(0);
        for (int r=0; r<4; r++) {
          temp_String.append(String.format("%02X", (int) W[r][c]));
        }
      }
    }

    // To save the last round key
    temp_answer.add(temp_String.toString());
    temp_String.setLength(0);

    // Transfer all keys to a String[] in UpperCase
    for (int i=0; i<answer.length; i++) {
      answer[i] = temp_answer.get(i);
    }

    return answer;
  }
}
